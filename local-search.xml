<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="/2023/05/28/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2023/05/28/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>模块化编程的<strong>目标</strong>是将<strong>不同作者和来源的代码</strong>模块<strong>组装</strong>成大型程序。</p><p>模块化的作用主要体现在<strong>封装</strong>和<strong>隐私私有实现细节</strong>，保证全局<strong>命名空间上的清洁</strong>。</p><p>模块之间不会<strong>意外修改</strong>各种自定义的<strong>变量</strong>、<strong>函数</strong>、和<strong>类</strong>。</p><h2 id="了解模块模式"><a href="#了解模块模式" class="headerlink" title="了解模块模式"></a>了解模块模式</h2><p>模块是将代码拆分成独立的块，然后再把这些块连接起来。</p><p>这种模块的思想是: <strong>逻辑分块</strong>,<strong>各自封装</strong>,<strong>相互独立</strong>,每个块自选决定暴露什么，同时自选决定引入执行那些外部的代码。</p><p>流行的 JavaScript 模块化规范有 <strong>CommonJS</strong>、<strong>AMD</strong>、<strong>CMD</strong> 及 <strong>ESModule</strong> 模块化规范。</p><h2 id="模块化标准及发展"><a href="#模块化标准及发展" class="headerlink" title="模块化标准及发展"></a>模块化标准及发展</h2><p>1、全局形式的定义，没有模块化的概念，这样很难团队协同和定义。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过命名空间的方式，将内容定义在一个对象下，以此实现与外界作用域的隔离。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> util = &#123;<br>        <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>); <br>    &#125;<br>&#125;<br>util.foo();<br></code></pre></td></tr></table></figure><p>闭包实现</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"> <span class="hljs-keyword">var</span> util = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">var</span> person = <span class="hljs-string">&#x27;小明&#x27;</span><br>            <span class="hljs-keyword">var</span> personName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person);<br>            &#125;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">personName</span>: personName<br>            &#125;<br><br>&#125;)();<br>util.personName();<br></code></pre></td></tr></table></figure><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>模块化得到实质性推动得力于 nodejs 的发展，最早模块化规范取得不错实践要追溯到2009年，CommonJS 这时还叫 ServerJS，其对应规范定义为 Modules&#x2F;1.0。<a href="https://wiki.commonjs.org/wiki/Modules">https://wiki.commonjs.org/wiki/Modules</a></p><p>require是同步加载的</p><ul><li>运行时加载只有运行时才能得到这个对象(<a href="https://so.csdn.net/so/search?q=module&spm=1001.2101.3001.7020">module</a>.exports的对象)</li><li>对于基本数据类型，属于<strong>复制</strong>。即会被模块缓存。同时，<strong>在另一个模块可以对该模块输出的变量重新赋值</strong>。</li><li>在第一次加载之后会被缓存，引入的是<strong>缓存</strong>中的值</li><li>对于复杂数据类型，属于<strong>浅拷贝</strong>。由于两个模块引用的对象指向同一个内存空间，因此<strong>对该模块的值做修改时会影响另一个模块</strong>。</li></ul><h3 id="使用require-导入其他模块"><a href="#使用require-导入其他模块" class="headerlink" title="使用require()导入其他模块"></a>使用require()导入其他模块</h3><p>如果导入Node内置的系统模块或包管理器安装在系统上的模块，使用模块的非限定名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Node内置的模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">const</span> http = = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-comment">//本地安装的模块</span><br><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>)<br><span class="hljs-comment">//导入自己代码中的模块</span><br>通常用./ , ../以表示它们当前的目录或父目录<br><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./mysql.js&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>如果模块只导入一个函数或类，只需要调用<span class="hljs-built_in">require</span>()<br><span class="hljs-keyword">const</span> stats = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./stats.js&quot;</span>) <span class="hljs-comment">//导出stats对象，包含所有函数</span><br><br><span class="hljs-number">2.</span>使用解构赋值，向本地导入想要的函数<br><span class="hljs-keyword">const</span> &#123;stddv&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./stats.js&quot;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="使用module-exports对象导出公共的API"><a href="#使用module-exports对象导出公共的API" class="headerlink" title="使用module.exports对象导出公共的API"></a>使用module.exports对象导出公共的API</h3><p>如果要导出多个值的node模块使用exports对象,只想导出一个函数或类时使用module.exports</p><h2 id="AMD（Async-Module-Definition）"><a href="#AMD（Async-Module-Definition）" class="headerlink" title="AMD（Async Module Definition）"></a>AMD（Async Module Definition）</h2><p>首先明确，这俩规范的代表作分别为：</p><p>AMD —— RequireJS</p><p>CMD —— SeaJS</p><p>还记得我们前面提到，如果模块化导入是同步的，那么我们是不是只有等待内容导入加载完后才可以执行？假设导入是异步的，那么会出现什么情况？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>CommonJS Syntax<br>const Person = require(<span class="hljs-string">&quot;Person&quot;</span>);<br><br><span class="hljs-keyword">function</span> Programmer ()&#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-keyword">do</span> something<br>&#125;<br><br>Programmer.prototype = new Person();<br><br><span class="hljs-regexp">//</span>如果 require call 是异步的，那么这段代码肯定是无法执行的，因为在执行这句前 Person 模块还未加载<br></code></pre></td></tr></table></figure><h2 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h2><p>2015 年，这时 babel 开始流行，不得不说，JavaScript 的发展离不开社区的推动。</p><p>Use next generation JavaScript, today.</p><p>我们去 ECMA 考考古吧</p><p>关于 exports，<a href="https://262.ecma-international.org/6.0/#sec-exports">https://262.ecma-international.org/6.0/#sec-exports</a></p><p>关于 imports，<a href="https://262.ecma-international.org/6.0/#sec-imports">https://262.ecma-international.org/6.0/#sec-imports</a></p><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>要从ES6模块导出常量、变量、函数、类，只需要在声明前加上export关键字即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a1 = <span class="hljs-string">&#x27;aaaa&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;bbbb&#x27;</span>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要导出多个，先定义常量，变量，函数和类，不加export关键字，然后再末尾只用一个export关键字导出真正想要导出的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a1 = <span class="hljs-string">&#x27;aaaa&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;bbbb&#x27;</span>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> &#123;a1,f1,<span class="hljs-title class_">Person</span>&#125;;<br></code></pre></td></tr></table></figure><p>export default默认导出</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>只有一个值的情况下，使用export default可以简化使用导出值的模块代码。</p><p>使用export的常规导出只对有名字的声明有效，而使用export default的默认导出则可以导出任意表达式，包括<strong>匿名函数表达式</strong>和<strong>匿名类表达式</strong>。</p><p>这意味着export default可以导出字面量</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>导入使用import关键字</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./a.js&quot;</span>;<br></code></pre></td></tr></table></figure><p>导出多个值</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> &#123;mean, a&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./stats.js&quot;</span>;<br></code></pre></td></tr></table></figure><p>批量导入</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span>  起的别名  <span class="hljs-keyword">from</span> ‘模块路径&#x27;<br></code></pre></td></tr></table></figure><h2 id="模块打包工具与工程化实践"><a href="#模块打包工具与工程化实践" class="headerlink" title="模块打包工具与工程化实践"></a>模块打包工具与工程化实践</h2><ol><li><strong>Modules&#x2F;1.x</strong>。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href="http://wiki.commonjs.org/wiki/Modules/Transport">Modules&#x2F;Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。后来衍生出值得关注的两个实现： <a href="https://github.com/component/component">component</a> 和 <a href="https://github.com/square/es6-module-transpiler">es6 module transpiler</a>。</li><li><strong>Modules&#x2F;Async</strong>。这个观点觉得浏览器有自身的特征，不应该直接用 Modules&#x2F;1.x 规范。这个观点下的典型代表是 <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">AMD</a> 规范及其实现 <a href="http://requirejs.org/">RequireJS</a>。</li><li><strong>Modules&#x2F;2.0</strong>。这个观点觉得浏览器有自身的特征，不应该直接用 Modules&#x2F;1.x 规范，但应该尽可能与 Modules&#x2F;1.x 规范保持一致。这个观点下的典型代表是 <a href="https://code.google.com/p/bravojs/">BravoJS</a> 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 <a href="http://www.page.ca/~wes/CommonJS/modules-2.0-7/">Modules&#x2F;2.0-draft</a> 规范花了很多心思。FlyScript 的作者提出了** <strong><strong>Modules&#x2F;Wrappings</strong></strong> <strong>规范，这规范是</strong> <strong><strong>CMD</strong></strong> **规范的前身。可最终 BravoJS 和 FlyScript 还是走向了衰落。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>this的指向</title>
    <link href="/2023/05/28/this%E7%9A%84%E6%8C%87%E5%90%91/"/>
    <url>/2023/05/28/this%E7%9A%84%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1><p>this永远指向一个对象</p><p>this的指向和他调用的环境有关</p><h2 id="全局作用域下this的指向"><a href="#全局作用域下this的指向" class="headerlink" title="全局作用域下this的指向"></a>全局作用域下this的指向</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">全局作用域下 <span class="hljs-keyword">this</span>的指向<br>console.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 指向window</span><br><span class="hljs-comment">//这时打印宿主根对象，在浏览器中是window,在node中是global对象</span><br></code></pre></td></tr></table></figure><h2 id="对象中的this指向"><a href="#对象中的this指向" class="headerlink" title="对象中的this指向"></a>对象中的this指向</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">关于对象的<span class="hljs-variable language_">this</span>指向<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-comment">//对象初始化时会绑定this,所以f1的指向是obj</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;o1&#x27;</span>,<br>  <span class="hljs-attr">f</span>: f1<br>&#125;<br>obj.<span class="hljs-title function_">f1</span>() <span class="hljs-comment">// obj</span><br><br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.name);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;o1&#x27;</span>,<br>  <span class="hljs-attr">f</span>: f1<br>&#125;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;o2&#x27;</span><br>obj.f1() <span class="hljs-comment">// o1</span><br>f1()<span class="hljs-comment">//o2</span><br><span class="hljs-comment">//这个例子证明了this的指向与调用有关和定义无关</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">局部<span class="hljs-variable language_">this</span>的指向<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;o3&#x27;</span>,<br>      <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 指向obj</span><br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//指向window</span><br>      &#125;<br>       <span class="hljs-title function_">sayName</span>(); <br>     &#125;<br> &#125;<br>obj1.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">//对象的函数会发生this的自动绑定，但不代表函数内部的函数会自动绑定this</span><br></code></pre></td></tr></table></figure><h2 id="构造函数中的this指向"><a href="#构造函数中的this指向" class="headerlink" title="构造函数中的this指向"></a>构造函数中的this指向</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//构造函数中的this</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;a2&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">//a1</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">//a2</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;a1&#x27;</span>)<br>p1.<span class="hljs-title function_">sayName</span>()<br><br></code></pre></td></tr></table></figure><h1 id="改变this的指向"><a href="#改变this的指向" class="headerlink" title="改变this的指向"></a>改变this的指向</h1><p>call</p><p>aplly</p><p>bind</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3组件通信</title>
    <link href="/2023/05/23/vue3%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/05/23/vue3%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue3的组件通信大致分为3类"><a href="#Vue3的组件通信大致分为3类" class="headerlink" title="Vue3的组件通信大致分为3类"></a>Vue3的组件通信大致分为3类</h2><ul><li>父子组件通信</li><li>兄弟组件通信</li><li>跨级通信</li></ul><p>Vue3父子组件传值</p><p>1、使用props将数据传递给子组件</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">//父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child.vue&#x27;</span> </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> str = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;str&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> num = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msg&quot;</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">//子组件 Child.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">num</span>: <span class="hljs-title class_">Number</span>,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">props.msg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">props.num</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>2.emit触发父组件事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">//子组件 Child.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;click&quot;</span>])</span><br><span class="language-javascript">   <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-number">1</span>)</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleChange&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">//父组件<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> form <span class="hljs-string">&quot;./Child&quot;</span> </span><br><span class="language-javascript"> <span class="hljs-keyword">const</span> <span class="hljs-title function_">click</span> = (<span class="hljs-params">e</span>) =&gt;&#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(e);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;click&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>defineProps</code> 和 <code>defineEmits</code> 都是只能在 <script setup> 中使用的编译器宏</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>防抖和节流</title>
    <link href="/2023/05/11/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <url>/2023/05/11/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>防抖（debounce）:函数在一段时间内的多次调用，仅使得最后一次调用有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,t</span>)&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>     timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>   fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>&#125;,t)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流(throttle): 当事件触发后，指定时间内不能在触发</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> throttle = <span class="hljs-keyword">function</span> <span class="hljs-params">(fn, t)</span> &#123;<br>    let timer, arg<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>        arg = args<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span><br>        fn(...arg)<br>        arg = <span class="hljs-literal">null</span>;<br>        timer = setTimeout(() =&gt; &#123;<br>            timer = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (arg) f(...arg)<br>        &#125;, t)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>节流—王者荣耀释放技能 防抖—王者荣耀回城</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ref与reactive</title>
    <link href="/2023/05/03/ref%E4%B8%8Ereactive/"/>
    <url>/2023/05/03/ref%E4%B8%8Ereactive/</url>
    
    <content type="html"><![CDATA[<h2 id="组合式-API：setup"><a href="#组合式-API：setup" class="headerlink" title="组合式 API：setup()"></a>组合式 API：setup()</h2><p>vue3的 <code>setup()</code> 函数是组件中的一个新特性，用于替代Vue2中的<code>created()</code>和<code>mounted()</code>生命周期函数，并且提供了更加灵活的响应式数据绑定和逻辑复用。</p><p><code>setup()</code>函数接收两个参数，第一个参数为props对象，第二个参数为上下文对象。在<code>setup()</code>函数内部，可以通过返回一个对象来暴露组件中需要使用的响应式数据、计算属性、方法等。</p><p>在Vue3中，响应式数据的创建方式有所变化，需要使用<code>ref()</code>或<code>reactive()</code>函数进行创建。<code>ref()</code>用于创建基本数据类型的数据，而<code>reactive()</code>用于创建引用数据类型的数据。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">num1</span>  &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addClick&quot;</span>&gt;</span>加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;num1--&quot;</span>&gt;</span>减<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Ref</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-attr">num1</span>:<span class="hljs-title class_">Ref</span>&lt;number&gt; = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//或 const num1 =  ref&lt;number&gt;(0)</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">addClick</span> = (<span class="hljs-params"></span>)=&gt;&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    num1.<span class="hljs-property">value</span> += <span class="hljs-number">1</span>;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>1.template中ref会自动浅层解包，无须写.value</p><p>2.在setup中使用要.value</p><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-variable">&lt;template&gt;</span><br>    <span class="hljs-variable">&lt;div&gt;</span><br>       <span class="hljs-variable">&lt;span&gt;</span>&#123;&#123; <span class="hljs-keyword">state</span>.count &#125;&#125;&lt;/span&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br><span class="hljs-variable">&lt;script setup&gt;</span><br>import &#123; reactive &#125; <span class="hljs-keyword">from</span> &#x27;vue&#x27;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = reactive(&#123;<br>  count: <span class="hljs-number">0</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> addCount = ()=&gt;&#123;<br>  <span class="hljs-keyword">state</span>.count++<br>&#125;<br><br>&lt;/script&gt;<br><br><span class="hljs-variable">&lt;style scoped&gt;</span><br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>当需要对一个 “reactive” 对象的某个属性进行赋值操作时，直接对这个属性进行赋值即可。因为这个对象本身就是响应式的，无需使用 “.value” 属性。</p><h3 id="reactive使用注意点"><a href="#reactive使用注意点" class="headerlink" title="reactive使用注意点"></a>reactive使用注意点</h3><ol><li><p>reactive只使用于对象类型，如对象，数组，集合，不适用于原始类型</p></li><li><p>从reactive返回的代理对象与原始对象是不一样的。用<code>===</code>操作符进行比较会返回<code>false</code>，所以必须保持对响应式对象的相同引用，不能解构成局部变量。可以使用toRefs将对象的所有属性转换为响应式的然后再解构才不会失去响应式。</p></li><li><p>不重新赋值reactive对象，重新替换一个响应式对象。新的对象会覆盖，响应式连接会丢失。</p></li><li><p>传递reactive对象中的属性到函数中，响应式连接也会丢失。</p><p>​</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何写好一份技术博客</title>
    <link href="/2023/04/29/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%BB%BD%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/04/29/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%BB%BD%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="这个答案由四部分组成"><a href="#这个答案由四部分组成" class="headerlink" title="这个答案由四部分组成"></a>这个答案由四部分组成</h3><ul><li>博客的流量来源</li><li>不同文章类型的写作要点</li><li>如何写博客</li><li>如何收集写作的灵感</li></ul><h3 id="技术博客类型"><a href="#技术博客类型" class="headerlink" title="技术博客类型"></a>技术博客类型</h3><ul><li>技术细节型</li><li>干货型</li><li>实践总结型</li><li>杂谈与鸡汤型</li></ul><p><img src="https://pica.zhimg.com/d10e850c549258a3a2d8f7025d25f95f_r.jpg?source=1940ef5c"></p><h4 id="技术细节型"><a href="#技术细节型" class="headerlink" title="技术细节型"></a>技术细节型</h4><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">这种类型主要来自于日常工作，如某个第三库更新，某个浏览器bug，如何使用某个技术。因此，我们就会用这样的关键字和词去搜索。</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">标题的前半部分是关键字，后半部分指名意图。</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">如</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Mac OS Laravel 安装</span><br><br><span class="hljs-attribute">需要注意几点</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-bullet">-</span> <span class="hljs-string">表达一些技术上的细节</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">以学习的角度去想</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">加入一点点自己的情感</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">编写更简洁的内容</span><br></code></pre></td></tr></table></figure><h4 id="干货型"><a href="#干货型" class="headerlink" title="干货型"></a>干货型</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">一般来说，这种类型的文章更类似于GitHub上的那些Awesome类型的Repo。说说几个标题，大概可能就会有点感觉了:</span><br>每个程序员必知之SEO<br>作为一个前端工程师你了解你的小伙伴么 - chrome<br>App 上架相关事宜、解决技巧<br></code></pre></td></tr></table></figure><h4 id="实践总结型"><a href="#实践总结型" class="headerlink" title="实践总结型"></a>实践总结型</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h4 id="杂谈与鸡汤型"><a href="#杂谈与鸡汤型" class="headerlink" title="杂谈与鸡汤型"></a>杂谈与鸡汤型</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h3 id="如何写博客"><a href="#如何写博客" class="headerlink" title="如何写博客"></a>如何写博客</h3><p>对于博客的内容来说，下面几点很重要哦：</p><ul><li><p>标题、小标题。一个好的标题会带来更多的流量的。</p></li><li><p>内容。以代码为例的文章，最好有代码。代码可以放在GitHub上，一举两得。</p></li><li><p>图 —— 一图胜千言，如本文第一节中的框架图。，一个框架图可以省去你的很多话语。</p></li><li><p>排版，又可称为UI设计。基本的语法高亮要有，容易阅读也要有。最简单就是白底黑字。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">标题——必须重要，类名<br></code></pre></td></tr></table></figure><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">小标题——地图，<span class="hljs-keyword">method</span>,他就是站点地图，一点就到了相应的地方。<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">内容——函数体,你写得越复杂，别人看的时间就越久，通俗易懂，就是一个很好的开始。<br><br>编写内容的时候需要注意下面的几点：<br><br>代码。必要的时候贴出代码<br>列表。列表可以简明扼要的说明你想要表达的内容。<br>图表。一张流程图可以说明程序的步骤，一个表格可以作好一个对比。<br>标题。标题的好处，可以让用户快速定位,让用户找到想要的内容。<br>链接。一个好的<span class="hljs-built_in">URL</span>对于使用英文的人来说，可以利于SEO,对于中文，使用的人可以判断出文章的专业与否。<br></code></pre></td></tr></table></figure></li></ul><h3 id="如何收集写作的灵感"><a href="#如何收集写作的灵感" class="headerlink" title="如何收集写作的灵感"></a>如何收集写作的灵感</h3><p>一般是先有个论点，然后再论据，最后才写。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h3 id="确定纲要"><a href="#确定纲要" class="headerlink" title="确定纲要"></a>确定纲要</h3><p><img src="https://pic1.zhimg.com/80/v2-21d3e223708a307648692756c61f2bcc_720w.webp?source=1940ef5c"></p><p><img src="https://pic1.zhimg.com/80/v2-e0b0051f766e361536ca0ecf06762d33_720w.webp?source=1940ef5c"></p><p><img src="https://picx.zhimg.com/80/v2-deacf67ac52f18ee845369ba970fa3a6_720w.webp?source=1940ef5c"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
